package tp.dominio;

import java.time.LocalTime;
import java.util.ArrayList;
import java.util.PriorityQueue;



public class PruebaGrafos {
	
	public static int rint(int mod) {
		long x = System.nanoTime();
		x ^= (x << 21);
		x ^= (x >>> 35);
		x ^= (x << 4);
		return ((int)x%mod+mod)%mod; // XORshift random, porque el random de java no es muy bueno
	}
	public static double rdb(int mod) {
		double ret = Math.random()*100 % mod;
		return ret;
	}
	public static long dijkstra(int src, int to, int tipo, ArrayList<ArrayList<Edge>> grafo, int N) {
		long INF = 100000009; // me gustaria que sea const, averiguar si se puede. no me deja static
		long[] dist = new long[N];
		int[] dad = new int[N];
		for(int i=0; i<N; i++) dist[i] = INF;
		PriorityQueue<long[]> pq = new PriorityQueue<long[]>((x,y)->Long.compare(x[1], y[1]));
		dist[src] = 0;
		pq.add(new long[] {src,0});
		while(!pq.isEmpty())
		{
			long[] cur = pq.remove();
			int node=(int)cur[0];
			long cost=cur[1];
			if(cost > dist[node]) continue;
			for(Edge nxt: grafo.get(node)) {
				if(cost + nxt.getDato(tipo) < dist[nxt.getDestino()]) {
					dad[nxt.getDestino()] = node;
					pq.add(new long[] {nxt.getDestino(), dist[nxt.getDestino()] = cost + nxt.getDato(tipo) });
				}
			}
		}
		return dist[to];
	}
	
//	
//		if(dist[t]<INF)//path generator
//			for(int i=t; i!=-1; i=dad[i])
//				printf("%d%c", i, (i==s?'\n':' '));}
	
	
	public static void main(String[] args) {
		
		//for(int i=0; i<30; i++) System.out.print(rint(8) + " ");
		
		
		//esto hay que moverlo
		//Map<Integer, ArrayList<Ruta>> grafo = new HashMap<Integer, ArrayList<Ruta>>();
		// con cada linea reconstruimos el grafo
		ArrayList<Linea> lineas = new ArrayList<Linea>(); // pedir a la BD que me de todas las lineas 
		
		//genero 2 lineas
		Linea l1 = new Linea("linea 1", "azul", true);
		Linea l2 = new Linea("linea 2", "rojo", true);
		
		//genero 8 estaciones
		ArrayList<Estacion> e = new ArrayList<Estacion>();
		for(int i=0; i<8; i++) {
			LocalTime time1 = LocalTime.now();
			LocalTime time2 = LocalTime.now();
			String aux = "est ";
			aux = aux+(char)(i+'0');
			Estacion est = new Estacion(i, aux, time1, time2, "op");
			e.add(est);
		}
		
		//genero 8 rutas
		ArrayList<Ruta> rutas = new ArrayList<Ruta>();
		for(int i=0; i<8; i++) {
			int dist = rint(100),t1=rint(100), mxp = rint(100);
			int ix = rint(8);
			System.out.print(" ");
			int ix2 = rint(8);
			if(ix == ix2) ix2 = (ix2+1)%8;
			if(rint(2) > 0) {
				int aux = ix2;
				ix2 = ix;
				ix = aux;
			}
			System.out.print(ix + " " + ix2 + " ");
			Ruta ruta = new Ruta(e.get(ix), e.get(ix2), dist,t1,mxp,true,rint(100));      
			System.out.println("Ruta numero " + i + " " + ruta.getOrigen().getId() + " " + ruta.getDestino().getId());
			rutas.add(ruta);
		}
		ArrayList<Ruta> aux = new ArrayList<Ruta>();
		for(int i=0; i<5; i++) {
			int nuevaRuta = rint(8);
			aux.add(rutas.get(nuevaRuta));
			System.out.println("Agrego a linea 1, la ruta " + nuevaRuta + " que va desde " + rutas.get(nuevaRuta).getOrigen().getId() + " hasta " + rutas.get(nuevaRuta).getDestino().getId());
		}
		l1.setRecorrido(aux);
		aux.clear();
		for(int i=0; i<5; i++) {
			int nuevaRuta = rint(8);
			aux.add(rutas.get(nuevaRuta));
			System.out.println("Agrego a linea 2, la ruta " + nuevaRuta + " que va desde " + rutas.get(nuevaRuta).getOrigen().getId() + " hasta " + rutas.get(nuevaRuta).getDestino().getId());
			
		}
		l2.setRecorrido(aux);
		lineas.add(l1); lineas.add(l2);
		int N = 1;
		for(Linea l :lineas) {
			ArrayList<Ruta> recorrido = l.getRecorrido();
			for(Ruta r : recorrido) {
				N = Math.max(N, r.getOrigen().getId()+1);
				N = Math.max(N, r.getDestino().getId()+1);
			}
		}
		ArrayList<ArrayList<Edge>> grafo = new ArrayList<ArrayList<Edge>>();
		for(int i=0; i<N; i++) grafo.add(new ArrayList<Edge>());
		 
		for(Linea l : lineas) {
			ArrayList<Ruta> recorrido = l.getRecorrido();
			System.out.println("Rutas de " + l.getNombre());
			for(Ruta r : recorrido) {
				System.out.println("from " + r.getOrigen().getId() + " to " + r.getDestino().getId());
				Edge edgeDestino = new Edge(r);
				grafo.get(r.getOrigen().getId()).add(edgeDestino);
			}
		}
		System.out.println("Cant nodos " + N);
		for(int i=0; i<N; i++) {
			System.out.println("Aristas salientes del nodo " + i);
			for(Edge j : grafo.get(i)) {
				System.out.println("Edge to" + j.getDestino() + " tiempo " + j.getDato(0) + " dist " + j.getDato(1));
			}          
		}
		//hay que controlar los multiedges? eso agrega complejidad n^2, puedo hacer nlogn tb y se amortiza con dijk
		
		//sig paso armar el dijkstra :)
		for(int i=0; i<N; i++) {
			if(grafo.get(i).size() > 0) {
				System.out.println("Dijkstra para el nodo " + i);
				for(int j=0; j<N;j++) if(j!=i) System.out.println("To " + j + " dist " + dijkstra(i,j,0,grafo,N));
				break;
			}
		}
//		
//		long dijkstra(int s, int t){//O(|E| log |V|)
//			static int INF = 1000000009;
//			priority_queue<ii, vector<ii>, greater<ii> > Q;
//			long[] dist = new long[N]; // setear a inf
//			
//			vector<int> dad(N, -1);
//			Q.push(make_pair(0, s)); dist[s] = 0;
//			while(sz(Q)){
//				ii p = Q.top(); Q.pop();
//				if(p.snd == t) break;
//				forall(it, G[p.snd])
//					if(dist[p.snd]+it->first < dist[it->snd]){
//						dist[it->snd] = dist[p.snd] + it->fst;
//						dad[it->snd] = p.snd;
//						Q.push(make_pair(dist[it->snd], it->snd));	}
//			}
//			return dist[t];
//			if(dist[t]<INF)//path generator
//				for(int i=t; i!=-1; i=dad[i])
//					printf("%d%c", i, (i==s?'\n':' '));}
	}
}
